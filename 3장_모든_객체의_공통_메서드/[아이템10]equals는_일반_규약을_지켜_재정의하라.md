equals 메서드는 재정의하기 쉬워 보이지만 곳곳에 함정이 도사리고 있다. <br> 
문제를 회피하는 가장 쉬운 길은 아예 재정의하지 않는 것이다. <br> 

<h3> 아래 사항 중 하나에 해당한다면 재정의하지 않는 것이 최선이다. </h3>  

* 각 인스턴스가 본질적으로 고유하다. 
  * 값을 표현하는 게 아니라 동작하는 개체를 표현하는 클래스가 여기 해당한다.
  * Thread가 좋은 예로, Object의 equals 메서드는 이러한 클래스에 딱 맞게 구현되었다. 
* 인스턴스의 '논리적 동치성을 검사할 일이 없다.' 
  * java.util.regex.Pattern은 equals를 재정의해서 두 Patteren의 인스턴스가 같은 정규표현식을 나타내는 지를 검사하는 방법도 있다. 
* 상위 클래스에서 재정의한 equals가 하위 클래스에도 딱 들어맞는다.
  * Set 구현체는 AbstractSet이 구현한 equals를 상속받아 쓰고, 
  *  List 구현체들은 AbstractList로부터, 
  *  Map 구현체들은 AbstractMap으로부터 상속받아 그대로 쓴다.
* 클래스가 private이거나 package-private이고 equals 메서드를 호출할 일이 없다.

<br> 

```java 
@Override
public boolean equals(Object o) {
  throw new AssertionError(); //호출 금지!
}
``` 
<br> <hr> 

- equals 재정의가 필요한 경우

객체 식별성 (두 객체가 물리적으로 같은가)이 아니라 논리적 동치성을 확인해야 하는데, <br> 
상위 클래스의 equals가 논리적 동치성을 비교하도록 재정의되지 않았을 때다. <br> 
주로 값 클래스들이 여기 해당된다. <br> 
<br> 
값 클래스란 Integer와 String 처럼 값을 표현하는 클래스를 말한다. <br> 
두 값 객체를 equals로 비교하는 프로그래머는 객체가 같은지가 아니라 값이 같은지를 알고 싶어할 것이다. <br> 
equals가 논리적 동치성을 확인하도록 재정의해두면, <br> 
그 인스턴스는 값을 비교하길 원하는 프로그래머의 기대에 부응함은 물론 Map의 키와 Set의 원소로 사용할 수 있게 된다. <br> 
<br> 
값 클래스라 해도, 값이 같은 인스턴스가 둘 이상 만들어지지 않음을 보장하는 인스턴스 통제 클래스라면 equals를 재정의하지 않아도 된다. <br> 
Enum도 마찬가지이다. <br> 
클래스에서는 어차피 논리적으로 같은 인스턴스가 2개 이상 만들어지지 않으니 <br> 
논리적 동치성과 객체 식별성이 사실상 똑같은 의미가 된다. <br> 
